#es6#

###使用箭头函数要注意的地方###
1、函数体内的this对象，是定义时所在的对象，而不是使用时所在的对象
2、不可以用作构造函数
3、不能使用arguments对象，改对象在函数体内不存在
4、不可以使用yield命令
以上要注意的地方归根于，箭头函数中根本没有自己的this，导致内部的this就是外层代码块的this。也不能用作箭头函数

###es6的let、const###
（1）let  

* 不存在变量提升。而且let绑定的区域，在变量声明之前，该变量都不可用的，所声明的变量也不受外部的影响
* 不允许在相同作用域内重复声明同一个变量
* 外层代码块不受内层代码块的影响
* 外层作用域无法读取内层作用域的变量

（2）const  

* const声明的变量值不得改变，而且必须声明后立即赋值负责就会报错
* const也是存在该let相同的特点

（3）块级作用域的好处  

* 没有块级作用域的话内层变量会覆盖外层变量（对应let第3点）
* for循环的变量会泄露为全局变量

###promise的理解###
promise是一个构造函数，用来生成promise实例。里面接受两个参数，一个是reject函数一个是resolve函数。当异步操作结束后返回的结果传给resolve或者reject

###async的理解###
async是Generator函数的语法糖，有内置的自执行器和一串异步操作。

#css+html#

###box-sizing盒模型###
设置盒模型的类型 box-sizing：content-box（默认）|border-box  

* border-box：width和height的值**包括**padding和border
* content-box：width和height的值**不包括**padding和border

###浏览器渲染原理###

###回流和重绘###
###BFC相关问题###

参考书籍《如何写出高性能DOM》

#js基础#
###this指向问题###
（1）解释this问题的一篇文档<https://www.cnblogs.com/pssp/p/5216085.html>
this不是在定义时确定，而是在执行时确定。谁最终调用了该函数this就指向谁
（2）修改this指向的方法


###变量var和作用域问题###

###创建对象的三种方法###
gitHub博客地址<https://yangwenfei.github.io/2017/03/28/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/>
（1）工厂模式（字面量）  
new Object()方式
（2）构造函数的方式
不管是构造函数的方式还是字面量的方式都没有做到抽象的特点。每一个实例都是一个单独的作用域。从而导致不同的作用域链和标示符解析，不同实例上的同名函数并不相同。
（3）原型链方式

###深拷贝和浅拷贝###
首要要知道数据类型  

* 基本数据类型：Number，String,Boolean，null，undefined
* 引用数据类型:objct对象，Array数组，function函数

关于数据类型的存储  

* 基本数据类型变量名和值都存储在栈内存中，复制一个变量的时候，就会开辟一块新的内存出来，所以对原来的变量值没有影响
* 引用数据类型变量存储在栈内存中值存储在堆内存中，会有一个连接变量和值的指针，复制一个对象、数组或者方法的时候，复制的是指针地址，指向了相同的堆内存。

深拷贝和浅拷贝是针对引用数据类型：如果B复制A之后，不修改对A也造成了影响就是浅拷贝，否则就是深拷贝

实现深拷贝的方法  
* 对数组的拷贝
* 对方法的拷贝
###js实现继承的几种方式###
（1）拷贝集成
（2）原型链实现集成
（3）组合集成


###new Foo()时发生了什么###
* 创建一个新对象
* 将this指向这个新对象
* 执行构造函数里的代码
* 返回新对象（this）

###script标签的defer、async的区别###

###同源与跨域###

###原型和闭包相关问题###

###DOM事件（js事件）###


###数组去重###

#vue#
#网络协议#
###https的握手过程###
#其他#
###性能优化###
###代码优化基本方法###